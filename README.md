# Sandata - Professional Security Assessment Platform

A production-ready Flask application that performs safe, authorized security checks on websites and payment pages. Professional security assessment tool featuring authentication, role-based access control, rate limiting, and asynchronous scanning.

**Deployment**: Automated CI/CD via GitHub Actions to Hetzner Kubernetes | Last updated: 2025-01-08

**IMPORTANT LEGAL & ETHICAL NOTICE:** Use this tool ONLY on systems you own or where you have explicit written permission to test. Unauthorized scanning is illegal and unethical.

## What's New in v2.0

### Phase 1 Production Features
- User Authentication - Secure login/registration system with password hashing
- Role-Based Access Control (RBAC) - Admin, User, and Guest roles
- Rate Limiting - Configurable limits per role (5/min, 50/hour for users)
- Async Scanning - Celery + Redis for background job processing
- Real-time Progress - Track scan status in real-time
- User Dashboard - Personal scan history and statistics
- Admin Panel - User management and system monitoring
- Testing Suite - Comprehensive unit and integration tests
- Enhanced Security - CSRF protection, session management, secure cookies

### Phase 2 AI Integration (Planned)
- **AI-Powered Vulnerability Analysis** - Intelligent analysis of scan results using Large Language Models (LLMs) to identify patterns and correlations
- **Smart Remediation Suggestions** - Context-aware, step-by-step remediation guidance generated by AI based on specific findings
- **Automated False Positive Reduction** - AI-assisted filtering to reduce false positives and improve scan accuracy
- **Natural Language Report Generation** - AI-generated executive summaries and detailed explanations in plain language
- **Predictive Security Analysis** - Machine learning models to predict potential vulnerabilities based on historical scan data
- **Intelligent Threat Prioritization** - AI-powered risk scoring to prioritize critical vulnerabilities
- **Automated Compliance Checking** - AI-assisted verification against security standards (OWASP, NIST, PCI DSS)
- **Context-Aware Recommendations** - Personalized security recommendations based on detected technologies and configurations

## Features

### Security Scanning Capabilities

#### General Security Scan (8 Core Tests)
1. HTTP Security Headers validation (CSP, X-Content-Type-Options, X-Frame-Options, HSTS, Referrer-Policy)
2. TLS/SSL Certificate inspection and expiry checks (validity, expiration, issuer, subject details)
3. Cookie Security flags analysis (HttpOnly, Secure, SameSite)
4. Reflected Input detection (XSS risk identification using benign test tokens)
5. Critical Files Exposure checks (.htaccess, .env, .git/config, backup.sql, config.php.bak)
6. Common Files/Endpoints exposure (robots.txt, sitemap.xml, /admin/, phpinfo.php)
7. CMS Detection (WordPress, Joomla, Drupal, Ghost, Wix, Squarespace, Webflow, Shopify)
8. Server Version exposure analysis (Apache, Nginx version leaks)

#### Payment Page Security Scan (14 Specialized Tests)
1. HTTPS Enforcement validation (HTTPS usage and HSTS header configuration)
2. Mixed Content detection (HTTP resources loaded on HTTPS pages)
3. Payment Form security analysis (form methods, action URLs, payment-related input fields)
4. CSRF Protection validation (CSRF tokens in forms - CRITICAL for payment forms)
5. reCAPTCHA/CAPTCHA detection (Google reCAPTCHA v2/v3/Enterprise, hCaptcha, Cloudflare Turnstile)
6. HTML5 Form Validation analysis (required, pattern, maxlength attributes and input types)
7. .htaccess File exposure check (verifies .htaccess files are not publicly accessible - CRITICAL if exposed)
8. Payment Gateway detection (Stripe, PayPal, Square, Braintree, Authorize.Net, Worldpay, Adyen)
9. PCI DSS Compliance indicators (PCI DSS badges, security header compliance)
10. JavaScript Security Analysis (inline scripts, third-party script validation, unknown sources)
11. Enhanced Cookie Security (Secure flag, HttpOnly flag, SameSite attribute validation)
12. Advanced TLS Configuration (TLS 1.2+ requirement, 128-bit minimum cipher strength, certificate expiration)
13. Credit Card Field Security (direct card input detection, CVV field validation, autocomplete settings)
14. Autocomplete Security (verifies sensitive payment fields have autocomplete disabled or appropriate values)

#### Advanced Scan Options (8 Invasive Tests - Authorization Required)
**WARNING: These tests are MORE INVASIVE and may trigger WAF/IDS alerts. Only use with explicit written permission!**

1. **SQL Injection Testing** - Tests common SQL injection vectors using safe payloads. Includes error-based SQLi, boolean-based blind SQLi, and time-based detection. May trigger WAF/IDS alerts.

2. **XSS Detection** - Tests for Cross-Site Scripting vulnerabilities using safe payloads. Detects reflected XSS, DOM-based XSS indicators, and dangerous JavaScript patterns. May trigger WAF/IDS alerts.

3. **CMS Plugin Vulnerability Check** - Checks detected CMS plugins, themes, and extensions against known vulnerability databases. Detects outdated WordPress/Joomla/Drupal versions and their plugins with known CVEs. Safe and non-invasive.

4. **Subdomain Enumeration** - Discovers subdomains using certificate transparency logs (crt.sh) and DNS lookups. Identifies potentially sensitive subdomains (dev, test, staging, admin). Safe and non-invasive.

5. **Port Scanning** - Scans common network ports using nmap to identify open services and potential attack vectors. Detects critical exposures (databases, admin ports). **WARNING: This is the most invasive test - will trigger security alerts!**

6. **Directory Bruteforcing** - Discovers hidden directories and files using common wordlists. Detects sensitive files (.env, .git, config files), admin panels, backups. Tests with 50ms delay between requests. **Only use with explicit written permission!**

7. **API Endpoint Discovery** - Discovers API endpoints, documentation (Swagger/OpenAPI, GraphQL), and sensitive information in APIs. Detects REST endpoints, versioning, debug endpoints. Safe and non-invasive.

8. **S3 Bucket Exposure Check** - Checks for publicly accessible AWS S3 buckets and misconfigurations. Generates potential bucket names from domain, extracts S3 URLs from page content, tests for public read/write access. Safe and non-invasive.

### Compliance & Standards

Sandata follows official cybersecurity regulations, guidelines, and frameworks from Canadian and International authorities:

#### Canadian Regulations & Guidelines
- **Critical Cyber Systems Protection Act (CCSPA)** - Establishes cybersecurity duties for operators in federally regulated critical sectors
- **PIPEDA (Personal Information Protection and Electronic Documents Act)** - Requires organizations to implement appropriate safeguards to protect personal data
- **Firewall Security Considerations (ITSAP.80.039)** - Provides guidance on securing firewalls and network security
- **Credential Stuffing Protection Strategies** - Recommends security controls to safeguard web services

#### International Standards & Frameworks
- **NIST SP 800-41 Rev.1** - U.S. Government WAF/Firewall Policy guidelines
- **NIST SP 800-94** - U.S. Government IDS/IPS Systems guidelines
- **ENISA WAF Guide** - European Union WAF Evaluation framework
- **OWASP WAFEC** - Industry-standard practical WAF Testing criteria

All security tests, vulnerability assessments, and scanning techniques implemented in Sandata align with the guidelines established by these authorities, ensuring reliable, accurate, and legally compliant security audits.

### User Management & Security
- **Authentication System** - Secure login with bcrypt password hashing
- **User Roles** - Admin, User, Guest with different privileges
- **Session Management** - Secure 2-hour sessions with HttpOnly cookies
- **Rate Limiting** - Prevent abuse with per-role limits
- **CSRF Protection** - WTForms CSRF tokens on all forms

### UI/UX Features
- Beautiful **Neumorphism UI** design
- Responsive design for all devices
- User Dashboard with scan history
- Admin Panel for system management
- Real-time scan progress tracking
- Detailed reports with step-by-step remediation
- JSON export functionality

## Installation

### Prerequisites
- Python 3.8 or higher
- Redis server (for Celery and rate limiting)
- pip (Python package manager)

### Quick Start

1. **Clone or navigate to the project directory:**
```bash
cd /path/to/security_tester
```

2. **Create a virtual environment (recommended):**
```bash
python3 -m venv venv
source venv/bin/activate  # On Linux/Mac
# or
venv\Scripts\activate  # On Windows
```

3. **Install dependencies:**
```bash
pip install -r requirements.txt
```

4. **Install and start Redis:**

**On Ubuntu/Debian:**
```bash
sudo apt-get install redis-server
sudo systemctl start redis
```

**On macOS (with Homebrew):**
```bash
brew install redis
brew services start redis
```

**On Windows:**
Download from https://github.com/microsoftarchive/redis/releases

**Using Docker:**
```bash
docker run -d -p 6379:6379 redis:latest
```

5. **Set up environment variables:**
```bash
# Copy the example file
cp .env.example .env

# Edit .env and set your configuration
nano .env  # or use your preferred editor
```

6. **Initialize the database:**
```bash
# The database will be created automatically on first run
# Default admin account will be created:
# Email: admin@example.com
# Password: admin123
# (Change these in .env before first run!)
```

7. **Run the Flask application:**
```bash
PORT=4444 python app.py
```

8. **Start Celery worker (in a new terminal):**
```bash
# Activate virtual environment first
source venv/bin/activate

# Start Celery worker
celery -A celery_worker.celery worker --loglevel=info
```

9. **Access the application:**
Open your browser and navigate to:
```
http://localhost:4444
```

## Configuration

### Environment Variables

Create a `.env` file in the project root (see `.env.example`):

```env
# Flask Configuration
FLASK_ENV=development
SECRET_KEY=your-secret-key-change-this
PORT=4444

# Database
DATABASE_URL=sqlite:///security_tester.db

# Redis (for rate limiting and Celery)
REDIS_URL=redis://localhost:6379/0
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# Admin Account (created on first run)
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=changeme123
```

### Rate Limiting Configuration

Edit `config.py` to adjust rate limits:

```python
RATE_LIMIT_GUEST = "2 per minute, 10 per hour"
RATE_LIMIT_USER = "5 per minute, 50 per hour"
RATE_LIMIT_ADMIN = "20 per minute, 200 per hour"
```

## Usage

### For End Users

1. **Register an Account**
   - Navigate to `/register`
   - Create your account with username, email, and password
   - Login automatically after registration

2. **Start a Scan**
   - Enter target URL (must start with `http://` or `https://`)
   - Select scan type (General or Payment Page)
   - Click "Start Scan"
   - Monitor progress in real-time

3. **View Results**
   - Access your dashboard at `/dashboard`
   - Review scan history
   - Click on any scan to view detailed report
   - Export results as JSON

4. **Security Tests Documentation**
   - Visit `/security_list` to see all 22 security tests
   - Understand what each test checks
   - Learn about the scoring system

### For Administrators

1. **Access Admin Panel**
   - Login with admin account
   - Navigate to `/admin`

2. **Manage Users**
   - View all registered users
   - Monitor user activity
   - Check scan statistics

3. **System Monitoring**
   - View all system scans
   - Monitor rate limiting effectiveness
   - Track system health

## API Documentation

All API endpoints require authentication (except `/api/health`).

### Authentication

```bash
# Login to get session cookie
curl -X POST http://localhost:4444/login \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "email=user@example.com&password=yourpassword" \
  -c cookies.txt

# Use session cookie for API requests
curl -b cookies.txt http://localhost:4444/api/results
```

### Endpoints

#### `POST /api/scan`
Start a general security scan (rate limited).

**Request:**
```json
{
  "target": "https://example.com",
  "async": true,
  "options": {}
}
```

**Response:**
```json
{
  "status": "queued",
  "result_id": "uuid",
  "task_id": "celery-task-id",
  "message": "Scan queued successfully"
}
```

#### `POST /api/scan/payment`
Start a payment page security scan (rate limited).

**Request:**
```json
{
  "target": "https://example.com/checkout",
  "async": true
}
```

#### `GET /api/task/<task_id>`
Get async task status and progress.

**Response:**
```json
{
  "state": "PROGRESS",
  "status": "Running payment security scan..."
}
```

#### `GET /api/results`
List all your scan results (admin sees all scans).

#### `GET /api/results/<result_id>`
Get specific scan result details.

#### `GET /api/health`
Health check endpoint (no authentication required).

**Response:**
```json
{
  "status": "ok",
  "version": "2.0",
  "features": {
    "authentication": true,
    "rate_limiting": true,
    "async_scanning": true
  }
}
```

## Testing

### Run Tests

```bash
# Run all tests
pytest

# Run with coverage report
pytest --cov=. --cov-report=html

# Run specific test file
pytest tests/test_auth.py

# Run with verbose output
pytest -v
```

### Test Coverage

The test suite includes:
- Authentication tests (login, register, logout, password hashing)
- Scanning functionality tests
- Rate limiting tests
- API endpoint tests
- RBAC tests

## Project Structure

```
security_tester/
├── app.py                      # Main Flask application with auth & rate limiting
├── config.py                   # Configuration management
├── models.py                   # Database models (User, ScanHistory)
├── forms.py                    # WTForms for authentication
├── tasks.py                    # Celery async tasks
├── celery_worker.py            # Celery configuration
├── requirements.txt            # Python dependencies
├── pytest.ini                  # Pytest configuration
├── .env.example               # Environment variables template
├── scanner/
│   ├── __init__.py
│   ├── scanner.py             # General security scanner
│   ├── payment_scanner.py     # Payment page scanner
│   └── db.py                  # Legacy database helper
├── templates/
│   ├── index.html             # Main scanner interface
│   ├── security_list.html     # Security tests documentation
│   ├── login.html             # Login page
│   ├── register.html          # Registration page
│   ├── dashboard.html         # User dashboard
│   ├── admin.html             # Admin panel
│   ├── 404.html               # Error page
│   └── 500.html               # Error page
├── static/
│   ├── style.css              # Neumorphism UI (1500+ lines)
│   └── app.js                 # Frontend JavaScript
└── tests/
    ├── __init__.py
    ├── test_auth.py           # Authentication tests
    ├── test_scanning.py       # Scanning tests
    └── test_rate_limiting.py  # Rate limiting tests
```

## Production Deployment

### Security Checklist

Before deploying to production:

1. Change `SECRET_KEY` to a strong random value
2. Update admin credentials
3. Set `FLASK_ENV=production`
4. Enable `SESSION_COOKIE_SECURE=True` (requires HTTPS)
5. Use PostgreSQL instead of SQLite (optional)
6. Set up proper Redis persistence
7. Configure firewall rules
8. Set up SSL/TLS certificates
9. Enable logging and monitoring
10. Regular backup strategy

### Recommended Stack

- **Web Server**: Nginx or Apache
- **WSGI**: Gunicorn or uWSGI
- **Database**: PostgreSQL
- **Cache/Queue**: Redis (persistent)
- **Process Manager**: Supervisor or systemd
- **Monitoring**: Prometheus + Grafana
- **Logging**: ELK Stack or CloudWatch

### Kubernetes Deployment

The application is deployed to Hetzner Kubernetes (k3s) using GitHub Actions CI/CD.

**Prerequisites:**
- Kubernetes cluster (k3s)
- Nginx Ingress Controller
- Redis deployment (included in k8s manifests)

**Deployment Process:**
1. Push to `main` branch triggers CI/CD
2. Tests run automatically
3. Docker image is built on Hetzner server
4. Kubernetes manifests are applied
5. Application is available at `https://sandata.janisrael.com`

**Kubernetes Resources:**
- Namespace: `sandata`
- Deployment: `sandata-app` (2 replicas)
- Service: `sandata-service`
- Ingress: `sandata-ingress`
- Redis: `redis` deployment and service
- PersistentVolumeClaim: `sandata-pvc` (2Gi for SQLite database)

## Troubleshooting

### Common Issues

**Issue**: `Connection refused` to Redis  
**Solution**: Ensure Redis is running: `redis-cli ping` should return `PONG`

**Issue**: Celery worker not starting  
**Solution**: Check Redis connection and ensure Celery is installed

**Issue**: Rate limit errors  
**Solution**: Wait for the rate limit window to reset or adjust limits in `config.py`

**Issue**: `ModuleNotFoundError`  
**Solution**: Install all dependencies: `pip install -r requirements.txt`

**Issue**: Database errors  
**Solution**: Delete `security_tester.db` and restart app to recreate

## Contributing

Improvements welcome! Consider adding:
- OAuth2 authentication (Google, GitHub)
- Two-factor authentication (2FA)
- PDF report generation
- Email notifications
- Webhook integrations
- More security tests
- Docker Compose setup
- CI/CD pipeline

## License & Disclaimer

This tool is provided for **educational and authorized testing purposes only**. The developers assume no liability for misuse or damage caused by this tool. Users are solely responsible for ensuring they have proper authorization.

**Always:**
- Get written permission before scanning
- Follow responsible disclosure practices
- Comply with applicable laws
- Respect privacy and data protection regulations

---

## Credits

**Created By**: Jan Francis Israel  
**Website**: https://janisrael.com  
**HuggingFace**: https://huggingface.co/swordfish7412  
**GitHub**: https://github.com/janisrael

---

**Project**: Sandata  
**Version**: 2.0  
**Status**: Production Ready  
**Last Updated**: November 2025

---

**Remember: Use this tool responsibly and only on systems you own or have explicit permission to test!**
